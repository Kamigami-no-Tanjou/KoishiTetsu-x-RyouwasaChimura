---
--- Generated by EmmyLua(https://github.com/EmmyLua)
---
--- A script that offers a few basic methods to treat CustomCommand instances.
---
--- @author RedNeath
--- @since 1.0.0
---
--- @licence MIT (https://github.com/Kamigami-no-Tanjou/KoishiTetsu-x-RyouwasaChimura/blob/main/LICENSE)
--- @return self
---
local CustomCommandService = {}
local env = require 'Chimura.SetEnvironment'
local sUtils = require 'Chimura.ServicesGlobalFunctions'
local mSv = require 'Chimura.Domain.Services.MemberService'
local caSv = require 'Chimura.Domain.Services.CommandArgService'
require 'Chimura.Domain.Entities.CustomCommand'

---
--- This local function retrieves the list of roles attributed to the given command.
---
--- @param customCommandId number The ID of the CustomCommand to seek roles for.
---
--- @return number[] The array of roles retrieved.
---
local function retrieveCustomCommandRoles(customCommandId)
    local roles = {}

    local requestSkeleton = [[
        SELECT RoleID AS roleId
        FROM RoleCustomCommand
        WHERE CustomCommandID = %s
    ]]

    local request = string.format(requestSkeleton, customCommandId)

    local result = assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")
    local row = result:fetch({})

    local i = 1
    while row do
        roles[i] = tonumber(row[1])

        row = result:fetch({})
        i = i + 1
    end
    result:close()

    return roles
end

---
--- This function aims to insert (only) the roles for the given custom command.
---
--- @param roles number[] The array of roles to attribute to the customCommand.
--- @param customCommandId number The ID of the custom command to which roles should be attributed.
---
--- @return void
---
local function insertRoleCustomCommands(roles, customCommandId)
    local requestSkeleton = [[
        INSERT INTO RoleCustomCommand(
            RoleID,
            CustomCommandID
        )
        VALUES
        %s
    ]]

    local valueSkeleton = [[
        (%s, %s)
    ]]

    local values = ""
    local isFirst = true
    for _,role in pairs(roles) do
        if not isFirst then
            values = values .. ", "
        else
            isFirst = false
        end

        values = values + string.format(valueSkeleton, role, customCommandId)
    end

    -- If, at the end of the loop, the values variable is nil, then there is no insert to make.
    if string.len(values) > 0 then
        local request = string.format(requestSkeleton, values)
        assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")
    end
end

---
--- This function aims to insert (only) the members for the given custom command.
---
--- @param members number[] The array of members to attribute to the customCommand.
--- @param customCommandId number The ID of the custom command to which members should be linked to.
---
--- @return void
---
local function insertMemberCustomCommands(members, customCommandId)
    local requestSkeleton = [[
        INSERT INTO MemberCustomCommand(
            MemberID,
            CustomCommandID
        )
        VALUES
        %s
    ]]

    local valueSkeleton = [[
        (%s, %s)
    ]]

    local values = ""
    local isFirst = true
    for _,member in pairs(members) do
        if not isFirst then
            values = values .. ", "
        else
            isFirst = false
        end

        values = values + string.format(valueSkeleton, member, customCommandId)
    end

    -- If, at the end of the loop, the values variable is nil, then there is no insert to make.
    if string.len(values) > 0 then
        local request = string.format(requestSkeleton, values)
        assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")
    end
end

---
--- This function's purpose is to delete the lines of RoleCustomCommand that are not within the list of roles for the
--- CustomCommand given.
---
--- @param roles number[] The array of roles that should be in the database for the given command.
--- @param customCommandId number The ID of the custom command this function is all about.
---
--- @return void
---
local function deleteRoleCustomCommandsNotIn(roles, customCommandId)
    local requestSkeleton = [[
        DELETE FROM RoleCustomCommand
        WHERE
            CustomCommandID = %s
            AND RoleID NOT IN (%s)
        ;
    ]]

    local roleList
    local isFirst = true
    for _,roleId in pairs(roles) do
        if not isFirst then
            roleList = roleList .. ", "
        else
            isFirst = false
        end

        roleList = roleList .. roleId
    end

    if roleList ~= nil then
        local request = string.format(requestSkeleton, customCommandId, roleList)
        assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")
    end
end

---
--- This function's purpose is to delete the lines of MemberCustomCommand that are not within the list of roles for the
--- CustomCommand given.
---
--- @param members number[] The array of members that should be in the database for the given command.
--- @param customCommandId number The ID of the custom command this function is all about.
---
--- @return void
---
local function deleteMemberCustomCommandsNotIn(members, customCommandId)
    local requestSkeleton = [[
        DELETE FROM MemberCustomCommand
        WHERE
            CustomCommandID = %s
            AND MemberID NOT IN (%s)
        ;
    ]]

    local memberList
    local isFirst = true
    for _,memberId in pairs(members) do
        if not isFirst then
            memberList = memberList .. ", "
        else
            isFirst = false
        end

        memberList = memberList .. memberId
    end

    if memberList ~= nil then
        local request = string.format(requestSkeleton, customCommandId, memberList)
        assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")
    end
end

---
--- This function's purpose is to update the association tables to linked to the CustomCommands.
---
--- @param roles number[] The array of roles that the row to update has. We'll use it to check that each of them is
--- synchronized within the database.
--- @param members number[] The array of members that the row to update is linked to. Same as for the roles, we'll
--- update the database with them so that it stays synchronized with the client.
---
--- @return void
---
local function updateAssociations(roles, members, customCommandId)
    deleteRoleCustomCommandsNotIn(roles, customCommandId)
    deleteMemberCustomCommandsNotIn(members, customCommandId)

    local existingRoles = retrieveCustomCommandRoles(customCommandId)
    local existingMembers = mSv.retrieveFromCustomCommandId(customCommandId)

    local rolesToInsert = {}
    local membersToInsert = {}

    local i = 1
    for _,roleId in pairs(roles) do
        local toInsert = true

        for _,existingRoleId in pairs(existingRoles) do
            if roleId == existingRoleId then
                toInsert = false

                break
            end
        end

        if toInsert then
            rolesToInsert[i] = roleId
            i = i + 1
        end
    end

    i = 0
    for _,memberId in pairs(members) do
        local toInsert = true

        for _,existingMemberId in pairs(existingMembers) do
            if memberId == existingMemberId then
                toInsert = false

                break
            end
        end

        if toInsert then
            membersToInsert[i] = memberId
            i = i + 1
        end
    end

    -- Finally we can do the inserts
    insertRoleCustomCommands(rolesToInsert, customCommandId)
    insertMemberCustomCommands(membersToInsert, customCommandId)
end

---
--- This function will delete all lines of RoleCustomCommand for the given command.
---
--- @param customCommandId number The ID of the CustomCommand
---
--- @return void
---
local function deleteRoleCustomCommands(customCommandId)
    local requestSkeleton = [[
        DELETE FROM RoleCustomCommand
        WHERE CustomCommandID = %s
        ;
    ]]

    local request = string.format(requestSkeleton, customCommandId)
    assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")
end

---
--- This function will delete all lines of MemberCustomCommand for the given command.
---
--- @param customCommandId number The ID of the CustomCommand
---
--- @return void
---
local function deleteMemberCustomCommands(customCommandId)
    local requestSkeleton = [[
        DELETE FROM MemberCustomCommand
        WHERE CustomCommandID = %s
        ;
    ]]

    local request = string.format(requestSkeleton, customCommandId)
    assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")
end

---
--- This function deletes all the RoleCustomCommands linked to a list of CustomCommands.
---
--- @param customCommandIds number[] The array of custom commands IDs.
---
--- @return void
---
local function deleteRoleCustomCommandsFromList(customCommandIds)
    local requestSkeleton = [[
        DELETE FROM RoleCustomCommand
        WHERE CustomCommandID IN
        (%s)
        ;
    ]]

    local values = ""
    local isFirst = true
    for _,customCommandId in pairs(customCommandIds) do
        if not isFirst then
            values = values .. ", "
        else
            isFirst = false
        end

        values = values .. customCommandId
    end

    if string.len(values) > 0  then
        local request = string.format(requestSkeleton, values)
        assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")
    end
end

---
--- This function deletes all the MemberCustomCommands linked to a list of CustomCommands.
---
--- @param customCommandIds number[] The array of custom commands IDs.
---
--- @return void
---
local function deleteMemberCustomCommandsFromList(customCommandIds)
    local requestSkeleton = [[
        DELETE FROM MemberCustomCommand
        WHERE CustomCommandID IN
        (%s)
        ;
    ]]

    local values = ""
    local isFirst = true
    for _,customCommandId in pairs(customCommandIds) do
        if not isFirst then
            values = values .. ", "
        else
            isFirst = false
        end

        values = values .. customCommandId
    end

    if string.len(values) > 0 then
        local request = string.format(requestSkeleton, values)
        assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")
    end
end

---
--- This function allows us to retrieve a CustomCommand from the DB thanks to its ID.
---
--- @param id number The primary key of the CustomCommand to retrieve.
---
--- @return CustomCommand The row of the DB corresponding to the given ID.
---
function CustomCommandService.retrieveFromId(id)
    assert(id ~= nil and id > 0, "{ \"err\":\"Bad ID!\" }")
    local requestSkeleton = [[
        SELECT
            ID AS id,
            Name AS name,
            Description AS description,
            Enabled AS enabled,
            Slashless AS slashless,
            TriggeredFromContent AS triggeredFromContent,
            Output AS output,
            GuildID AS guildID
        FROM CustomCommand
        WHERE ID = %s
        LIMIT 1
        ;
    ]]

    local request = string.format(requestSkeleton, id)

    local result = assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")
    local row = assert(result:fetch({}, "a"), "{ \"err\":\"No lines found!\" }")
    result:close()

    -- Retrieving the roles linked to this custom command
    row.roles = retrieveCustomCommandRoles(tonumber(row.id))

    -- Retrieving the members linked to this custom command
    row.members = mSv.retrieveFromCustomCommandId(tonumber(row.id))
    return CustomCommand:new(row)
end

---
--- This function allows us to retrieve the list of CustomCommand for the given Role
---
--- @param roleId number The Discord ID of the Role to retrieve CustomCommands from.
---
--- @return CustomCommand[] The array of CustomCommand attributed to the given Role.
---
function CustomCommandService.retrieveFromRoleId(roleId)
    local customCommands = {}

    assert(roleId ~= nil and roleId > 0, "{ \"err\":\"Bad ID!\" }")
    local requestSkeleton = [[
        SELECT
            CCM.ID AS id,
            CCM.Name AS name,
            CCM.Description AS description,
            CCM.Enabled AS enabled,
            CCM.Slashless AS slashless,
            CCM.TriggeredFromContent AS triggeredFromContent,
            CCM.Output AS output,
            CCM.GuildID AS guildID
        FROM RoleCustomCommand RCC
        INNER JOIN CustomCommand CCM
            ON RCC.CustomCommandID = CCM.ID
        WHERE RCC.RoleID = %s
        ;
    ]]

    local request = string.format(requestSkeleton, roleId)

    local result = assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")
    local row = result:fetch({}, "a")

    local i = 1
    while row do
        -- Since CustomCommands can be attributed to several roles:
        -- Retrieving the roles linked to the current custom command
        row.roles = retrieveCustomCommandRoles(tonumber(row.id))

        -- Retrieving the members linked to the current custom command
        row.members = mSv.retrieveFromCustomCommandId(tonumber(row.id))
        customCommands[i] = CustomCommand:new(row)

        row = result:fetch({}, "a")
        i = i + 1
    end

    result:close()
    return customCommands

    -- Another solution would be to request the DB for the list of ID of CustomCommand for the given role, and then call
    -- the previous method in a loop for each of them, but I don't really like that option since I think it is far less
    -- efficient than simply doing an inner join and retrieving everything at once, even if it sort of implies a code
    -- duplication (=> solved by the retrieveCustomCommandRoles local function)
end

---
--- This function allows us to retrieve the list of CustomCommand for the given Member
---
--- @param memberId number The primary key of the Member to retrieve CustomCommands from.
---
--- @return CustomCommand[] The array of CustomCommand attributed to the given Member.
---
function CustomCommandService.retrieveFromMemberId(memberId)
    local customCommands = {}

    assert(memberId ~= nil and memberId > 0, "{ \"err\":\"Bad ID!\" }")
    local requestSkeleton = [[
        SELECT
            CCM.ID AS id,
            CCM.Name AS name,
            CCM.Description AS description,
            CCM.Enabled AS enabled,
            CCM.Slashless AS slashless,
            CCM.TriggeredFromContent AS triggeredFromContent,
            CCM.Output AS output,
            CCM.GuildID AS guildID
        FROM MemberCustomCommand MCC
        INNER JOIN CustomCommand CCM
            ON MCC.CustomCommandID = CCM.ID
        WHERE MCC.MemberID = %s
        ;
    ]]

    local request = string.format(requestSkeleton, memberId)

    local result = assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")
    local row = result:fetch({}, "a")

    local i = 1
    while row do
        -- Retrieving the roles linked to the current custom command
        row.roles = retrieveCustomCommandRoles(tonumber(row.id))

        -- Since CustomCommands can be attributed to several members:
        -- Retrieving the members linked to the current custom command
        row.members = mSv.retrieveFromCustomCommandId(tonumber(row.id))
        customCommands[i] = CustomCommand:new(row)

        row = result:fetch({}, "a")
        i = i + 1
    end

    result:close()
    return customCommands
end

---
--- This function allows us to retrieve the list of CustomCommands for the given Guild
---
--- @param guildId number The primary key of the Guild to retrieve CustomCommands from.
---
--- @return CustomCommand[] The array of CustomCommands belonging to the given Guild.
---
function CustomCommandService.retrieveFromGuildId(guildId)
    local customCommands = {}

    assert(guildId ~= nil and guildId > 0, "{ \"err\":\"Bad ID!\" }")
    local requestSkeleton = [[
        SELECT
            ID AS id,
            Name AS name,
            Description AS description,
            Enabled AS enabled,
            Slashless AS slashless,
            TriggeredFromContent AS triggeredFromContent,
            Output AS output,
            GuildID AS guildID
        FROM CustomCommand
        WHERE GuildID = %s
        ;
    ]]

    local request = string.format(requestSkeleton, guildId)

    local result = assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")
    local row = result:fetch({}, "a")

    local i = 1
    while row do
        -- Retrieving the roles linked to the current custom command
        row.roles = retrieveCustomCommandRoles(tonumber(row.id))

        -- Retrieving the members linked to the current custom command
        row.members = mSv.retrieveFromCustomCommandId(tonumber(row.id))
        customCommands[i] = CustomCommand:new(row)

        row = result:fetch({}, "a")
        i = i + 1
    end

    result:close()
    return customCommands
end

---
--- This function's purpose is to insert or update the given CustomCommand object. It will check whether the object
--- already is in the DB or not, and decide on which to use based on that.
---
--- @param row CustomCommand The CustomCommand object to insert or update in the database.
---
--- @return void
---
function CustomCommandService.insertOrUpdate(row)
    local isNotNew = ((row.id or 0) ~= 0) --If id == nil => 0; if id == 0 => 0; if id > 0 => id;

    if isNotNew then    -- update
        local requestSkeleton = [[
            UPDATE CustomCommand
            SET
                Name = %s,
                Description = %s,
                Enabled = %s,
                Slashless = %s,
                TriggeredFromContent = %s,
                Output = %s
            WHERE ID = %s
            ;
        ]]

        local request = string.format(requestSkeleton,
                sUtils.varchar(row.name) or "NULL",
                sUtils.varchar(row.description) or "NULL",
                row.enabled,
                row.slashless,
                row.triggeredFromContent,
                sUtils.varchar(row.output) or "NULL",
                row.id
        )

        assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")
        -- No need to fetch anything here

        -- Now we need to update association tables (roles & members)
        updateAssociations(row.roles, row.members, row.id)

    else                -- insert
        local requestSkeleton = [[
            INSERT INTO CustomCommand(
                Name AS name,
                Description AS description,
                Enabled AS enabled,
                Slashless AS slashless,
                TriggeredFromContent AS triggeredFromContent,
                Output AS output,
                GuildID AS guildID
            ) VALUES (
                %s,
                %s,
                %s,
                %s,
                %s,
                %s,
                %s
            )
            ;
        ]]

        local request = string.format(requestSkeleton,
                sUtils.varchar(row.name) or "NULL",
                sUtils.varchar(row.description) or "NULL",
                row.enabled,
                row.slashless,
                row.triggeredFromContent,
                sUtils.varchar(row.output) or "NULL",
                row.guildId or "NULL"
        )

        assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")

        -- Now, as this is an insert, we have to insert the members and roles as well
        insertRoleCustomCommands(row.roles, row.id)
        insertMemberCustomCommands(row.members, row.id)
    end
end

---
--- This function's purpose is to delete the row of custom command at the given ID from the database.
--- Be aware that, just like the MySQL DELETE statement, this method will NOT throw any error if there was no custom
--- command to delete at the given id.
---
--- @param id number The ID of the custom command to remove from the database.
---
--- @return void
---
function CustomCommandService.deleteAtId(id)
    assert(id ~= nil and id > 0, "{ \"err\":\"Bad ID!\" }")

    -- Deleting all association tables lines.
    deleteRoleCustomCommands(id)
    deleteMemberCustomCommands(id)

    -- Then deleting all command arguments associated to this command.
    caSv.deleteAtCustomCommandId(id)

    local requestSkeleton = [[
        DELETE FROM CustomCommand
        WHERE ID = %s
        ;
    ]]

    local request = string.format(requestSkeleton, id)

    -- And finally deleting all proper custom commands.
    assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")
    -- Aaand... that's it. Nothing more to do here
end

---
--- This function's purpose is to delete all rows of custom commands for the given Guild
--- Be aware that, just like the MySQL DELETE statement, this method will NOT throw any error if there were no custom
--- commands to delete.
---
--- @param guildId number The ID of the Guild to remove command args from.
---
--- @return void
---
function CustomCommandService.deleteAtGuildId(guildId)
    assert(guildId ~= nil and guildId > 0, "{ \"err\":\"Bad ID!\" }")

    -- We retrieve the IDs of the CustomCommands to delete:
    local customCommandIds = {}
    local result = assert(env.con:execute("SELECT ID FROM CustomCommand WHERE GuildID = " .. guildId, "{ \"err\":\"Request failed!\" }"))
    local row = result:fetch({})

    local i = 1
    while row do
        customCommandIds[i] = tonumber(row[1])

        row = result:fetch({})
        i = i + 1
    end

    result:close()

    -- Deleting all the association tables lines.
    deleteRoleCustomCommandsFromList(customCommandIds)
    deleteMemberCustomCommandsFromList(customCommandIds)

    -- Then we delete all the command arguments.
    caSv.deleteFromCustomCommandList(customCommandIds)

    -- And we can finally delete all custom commands for the given guild.
    local requestSkeleton = [[
        DELETE FROM CustomCommand
        WHERE GuildID = %s
        ;
    ]]

    local request = string.format(requestSkeleton, guildId)

    assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")
    -- Aaand... that's it. Nothing more to do here
end

---
--- Calls for the environment set in this service to close. Has to be called at the very end of all treatments!!
---
--- @return void
---
function CustomCommandService.closeEnv()
    mSv.closeEnv()
    caSv.closeEnv()
    env.close()
end

return CustomCommandService