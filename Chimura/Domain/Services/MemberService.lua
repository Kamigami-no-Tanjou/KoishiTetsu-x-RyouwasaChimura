---
--- Generated by EmmyLua(https://github.com/EmmyLua)
---
--- A script that offers a few basic methods to treat Member instances.
---
--- @author RedNeath
--- @since 1.0.0
---
--- @licence MIT (https://github.com/Kamigami-no-Tanjou/KoishiTetsu-x-RyouwasaChimura/blob/main/LICENSE)
--- @return self
---
local MemberService = {}
local env = require 'Chimura.SetEnvironment'
local uSv = require 'Chimura.Domain.Services.UserService'
local gSv = require 'Chimura.Domain.Services.GuildService'
local wSv = require 'Chimura.Domain.Services.WarningService'
local ccSv = require 'Chimura.Domain.Services.CustomCommandService'
require 'Chimura.Domain.Entities.Member'

---
--- This function aims to insert (only) the custom commands for the given member.
--- It will look at what the parameters contains, and take customCommands if not nil, else customCommandsIds.
---
--- @param customCommands CustomCommand[] The array of custom commands to attribute to the member.
--- @param customCommandIds number[] The array of custom commands ids to attribute to the member.
--- @param memberId number The ID of the member to which custom commands should be linked to.
---
--- @return void
---
local function insertMemberCustomCommands(customCommands, customCommandIds, memberId)
    local useIds

    if customCommands == nil then
        useIds = true
    end

    local requestSkeleton = [[
        INSERT INTO MemberCustomCommand(
            MemberID,
            CustomCommandID
        )
        VALUES
        %s
    ]]

    local valueSkeleton = [[
        (%s, %s)
    ]]

    local values = ""
    local isFirst = true
    if useIds then
        for _, customCommandId in pairs(customCommandIds) do
            if not isFirst then
                values = values .. ", "
            else
                isFirst = false
            end

            values = values + string.format(valueSkeleton, memberId, customCommandId)
        end
    else
        for _, customCommand in pairs(customCommands) do
            if not isFirst then
                values = values .. ", "
            else
                isFirst = false
            end

            values = values + string.format(valueSkeleton, memberId, customCommand.id)
        end
    end

    -- If, at the end of the loop, the values variable is nil, then there is no insert to make.
    if string.len(values) > 0 then
        local request = string.format(requestSkeleton, values)
        assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")
    end
end

---
--- This function's purpose is to delete the lines of MemberCustomCommand that are not within the list of custom
--- commands for the Member given.
---
--- @param customCommands CustomCommand[] The array of custom commands that should be in the database for the given
--- command.
--- @param memberId number The ID of the member this function is all about.
---
--- @return void
---
local function deleteMemberCustomCommandsNotIn(customCommands, memberId)
    local requestSkeleton = [[
        DELETE FROM MemberCustomCommand
        WHERE
            MemberID = %s
            AND CustomCommandID NOT IN (%s)
        ;
    ]]

    local customCommandList
    local isFirst = true
    for _, customCommand in pairs(customCommands) do
        if not isFirst then
            customCommandList = customCommandList .. ", "
        else
            isFirst = false
        end

        customCommandList = customCommandList .. customCommand.id
    end

    if customCommandList ~= nil then
        local request = string.format(requestSkeleton, memberId, customCommandList)
        assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")
    end
end

---
--- This function's purpose is to update the association table linked to the Members.
---
--- @param customCommands CustomCommand[] The array of custom commands that the row to update has. We'll use it to check
--- that each of them is synchronized within the database.
--- @param memberId number The ID of the member. Practical for identifying the lines concerning it.
---
--- @return void
---
local function updateAssociations(customCommands, memberId)
    deleteMemberCustomCommandsNotIn(customCommands, memberId)

    local existingCustomCommands = ccSv.retrieveFromMemberId(memberId)

    local customCommandsToInsert = {}

    local i = 1
    for _, customCommand in pairs(customCommands) do
        local toInsert = true

        for _, existingCustomCommand in pairs(existingCustomCommands) do
            if customCommand.id == existingCustomCommand.id then
                toInsert = false

                break
            end
        end

        if toInsert then
            customCommandsToInsert[i] = customCommand.id
            i = i + 1
        end
    end

    -- Finally we can do the inserts
    insertMemberCustomCommands(nil, customCommandsToInsert, memberId)
end

---
--- This function will delete all lines of MemberCustomCommand for the given member.
---
--- @param memberId number The ID of the CustomCommand
---
--- @return void
---
local function deleteMemberCustomCommands(memberId)
    local requestSkeleton = [[
        DELETE FROM MemberCustomCommand
        WHERE MemberID = %s
        ;
    ]]

    local request = string.format(requestSkeleton, memberId)
    assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")
end

---
--- This function deletes all the MemberCustomCommands linked to a list of Members.
---
--- @param memberIds number[] The array of member IDs.
---
--- @return void
---
local function deleteMemberCustomCommandsFromList(memberIds)
    local requestSkeleton = [[
        DELETE FROM MemberCustomCommand
        WHERE MemberID IN
        (%s)
        ;
    ]]

    local values = ""
    local isFirst = true
    for _, memberId in pairs(memberIds) do
        if not isFirst then
            values = values .. ", "
        else
            isFirst = false
        end

        values = values .. memberId
    end

    if string.len(values) > 0 then
        local request = string.format(requestSkeleton, values)
        assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")
    end
end

---
--- This function allows us to retrieve a Member from the DB thanks to its ID.
---
--- @param id number The primary key of the Member to retrieve.
---
--- @return Member The row of the DB corresponding to the given ID.
---
function MemberService.retrieveFromId(id)
    assert(id ~= nil and id > 0, "{ \"err\":\"Bad ID!\" }")
    local requestSkeleton = [[
        SELECT
            ID AS id,
            Muted AS muted,
            UserID AS userId,
            GuildID AS guildID
        FROM Member
        WHERE ID = %s
        LIMIT 1
        ;
    ]]

    local request = string.format(requestSkeleton, id)

    local result = assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")
    local row = assert(result:fetch({}, "a"), "{ \"err\":\"No lines found!\" }")
    result:close()

    -- Retrieving the user linked to this custom command
    row.user = uSv.retrieveFromId(tonumber(row.userId))

    -- Retrieving the guild to which the member belongs
    row.guild = gSv.retrieveFromId(tonumber(row.guild))

    -- Retrieving the warning instance linked to this member
    row.warning = wSv.retrieveFromMemberId(tonumber(row.id))

    -- Retrieving the customCommands linked to this member
    row.customCommands = ccSv.retrieveFromMemberId(tonumber(row.id))
    return Member:new(row)
end

---
--- This function allows us to retrieve the list of Members for the given CustomCommand
---
--- @param customCommandId number The ID of the CustomCommand to retrieve Members from.
---
--- @return Member[] The array of Member attributed to the given CustomCommand.
---
function MemberService.retrieveFromCustomCommandId(customCommandId)
    local members = {}

    assert(customCommandId ~= nil and customCommandId > 0, "{ \"err\":\"Bad ID!\" }")
    local requestSkeleton = [[
        SELECT
            MBR.ID AS id,
            MBR.Muted AS muted,
            MBR.UserID AS userId,
            MBR.GuildID AS guildID
        FROM MemberCustomCommand MCC
        INNER JOIN Member MBR
            ON MCC.MemberID = MBR.ID
        WHERE MCC.CustomCommandID = %s
        ;
    ]]

    local request = string.format(requestSkeleton, customCommandId)

    local result = assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")
    local row = result:fetch({}, "a")

    -- Retrieving the guild to which the members belongs (only once 'cause a CustomCommand belongs to one guild only).
    local guild = gSv.retrieveFromId(tonumber(row.guildId))

    local i = 1
    while row do
        -- Retrieving the user linked to this member
        row.user = uSv.retrieveFromId(tonumber(row.userId))

        row.guild = guild

        -- Retrieving the warning instance linked to this member
        row.warning = wSv.retrieveFromId(tonumber(row.warning))

        -- Since Members can have several custom commands:
        -- Retrieving the customCommands linked to this member
        row.customCommands = ccSv.retrieveFromMemberId(tonumber(row.id))
        members[i] = Member:new(row)

        row = result:fetch({}, "a")
        i = i + 1
    end

    result:close()
    return members
end

---
--- This function allows us to retrieve the list of Members for the given User
---
--- @param userId number The primary key of the User to retrieve Members from.
---
--- @return Member[] The array of Members attributed to the given User.
---
function MemberService.retrieveFromUserId(userId)
    local members = {}

    assert(userId ~= nil and userId > 0, "{ \"err\":\"Bad ID!\" }")
    local requestSkeleton = [[
        SELECT
            ID AS id,
            Muted AS muted,
            UserID AS userId,
            GuildID AS guildID
        FROM Member
        WHERE UserID = %s
        ;
    ]]

    local request = string.format(requestSkeleton, userId)

    local result = assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")
    local row = result:fetch({}, "a")

    -- Retrieving the user to which the members belongs.
    local user = uSv.retrieveFromId(tonumber(row.userId))

    local i = 1
    while row do
        row.user = user

        -- Retrieving the guild to which the member belongs
        row.guild = gSv.retrieveFromId(tonumber(row.guildId))

        -- Retrieving the warning instance linked to this member
        row.warning = wSv.retrieveFromId(tonumber(row.warning))

        -- Retrieving the customCommands linked to this member
        row.customCommands = ccSv.retrieveFromMemberId(tonumber(row.id))
        members[i] = Member:new(row)

        row = result:fetch({}, "a")
        i = i + 1
    end

    result:close()
    return members
end

---
--- This function allows us to retrieve the list of Members for the given Guild
---
--- @param guildId number The primary key of the Guild to retrieve Members from.
---
--- @return Member[] The array of Members belonging to the given Guild.
---
function MemberService.retrieveFromGuildId(guildId)
    local members = {}

    assert(guildId ~= nil and guildId > 0, "{ \"err\":\"Bad ID!\" }")
    local requestSkeleton = [[
        SELECT
            ID AS id,
            Muted AS muted,
            UserID AS userId,
            GuildID AS guildID
        FROM Member
        WHERE GuildID = %s
        ;
    ]]

    local request = string.format(requestSkeleton, guildId)

    local result = assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")
    local row = result:fetch({}, "a")

    -- Retrieving the guild to which the members belongs.
    local guild = gSv.retrieveFromId(tonumber(row.guildId))

    local i = 1
    while row do
        -- Retrieving the user linked to this member
        row.user = uSv.retrieveFromId(tonumber(row.userId))

        row.guild = guild

        -- Retrieving the warning instance linked to this member
        row.warning = wSv.retrieveFromId(tonumber(row.warning))

        -- Retrieving the customCommands linked to this member
        row.customCommands = ccSv.retrieveFromMemberId(tonumber(row.id))
        members[i] = Member:new(row)

        row = result:fetch({}, "a")
        i = i + 1
    end

    result:close()
    return members
end

---
--- This function's purpose is to insert or update the given Member object. It will check whether the object already is
--- in the DB or not, and decide on which to use based on that.
---
--- @param row Member The Member object to insert or update in the database.
---
--- @return void
---
function MemberService.insertOrUpdate(row)
    local isNotNew = ((row.id or 0) ~= 0) --If id == nil => 0; if id == 0 => 0; if id > 0 => id;

    if isNotNew then    -- update
        -- Will only update the muted state and custom commands.
        local requestSkeleton = [[
            UPDATE Member
            SET
                Muted = %s
            WHERE ID = %s
            ;
        ]]

        local request = string.format(requestSkeleton, row.muted, row.id)

        assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")
        -- No need to fetch anything here

        -- Now we need to update association tables (custom commands)
        updateAssociations(row.customCommands, row.id)

    else                -- insert
        local requestSkeleton = [[
            INSERT INTO CustomCommand(
                Muted,
                UserID,
                GuildID
            ) VALUES (
                %s,
                %s,
                %s
            )
            ;
        ]]

        local request = string.format(requestSkeleton,
                row.muted,
                row.userId or "NULL",
                row.guildId or "NULL"
        )

        assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")

        -- Now, as this is an insert, we have to insert the custom commands as well
        insertMemberCustomCommands(row.customCommands, nil, row.id)
    end
end

---
--- This function's purpose is to delete the row of member at the given ID from the database.
--- Be aware that, just like the MySQL DELETE statement, this method will NOT throw any error if there was no member to
--- delete at the given id.
---
--- @param id number The ID of the member to remove from the database.
---
--- @return void
---
function MemberService.deleteAtId(id)
    assert(id ~= nil and id > 0, "{ \"err\":\"Bad ID!\" }")

    -- Deleting all association tables lines.
    deleteMemberCustomCommands(id)

    -- Then deleting the warning associated to this member.
    wSv.deleteAtMemberId()

    local requestSkeleton = [[
        DELETE FROM Member
        WHERE ID = %s
        ;
    ]]

    local request = string.format(requestSkeleton, id)

    -- And finally deleting all proper members.
    assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")
    -- Aaand... that's it. Nothing more to do here
end

---
--- This function's purpose is to delete all rows of members for the given User.
--- Be aware that, just like the MySQL DELETE statement, this method will NOT throw any error if there were no members
--- to delete.
---
--- @param userId number The ID of the User to remove members from.
---
--- @return void
---
function MemberService.deleteAtUserId(userId)
    assert(userId ~= nil and userId > 0, "{ \"err\":\"Bad ID!\" }")

    -- We retrieve the IDs of the Members to delete:
    local memberIds = {}
    local result = assert(env.con:execute("SELECT ID FROM Member WHERE UserID = " .. userId, "{ \"err\":\"Request failed!\" }"))
    local row = result:fetch({})

    local i = 1
    while row do
        memberIds[i] = tonumber(row[1])

        row = result:fetch({})
        i = i + 1
    end

    result:close()

    -- Deleting all the association tables lines.
    deleteMemberCustomCommandsFromList(memberIds)

    -- Then we delete all the warnings.
    wSv.deleteFromMemberList(memberIds)

    -- And we can finally delete all members for the given User.
    local requestSkeleton = [[
        DELETE FROM Member
        WHERE UserID = %s
        ;
    ]]

    local request = string.format(requestSkeleton, userId)

    assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")
    -- Aaand... that's it. Nothing more to do here
end

---
--- This function's purpose is to delete all rows of members for the given Guild
--- Be aware that, just like the MySQL DELETE statement, this method will NOT throw any error if there were no members
--- to delete.
---
--- @param guildId number The ID of the Guild to remove members from.
---
--- @return void
---
function MemberService.deleteAtGuildId(guildId)
    assert(guildId ~= nil and guildId > 0, "{ \"err\":\"Bad ID!\" }")

    -- We retrieve the IDs of the Members to delete:
    local memberIds = {}
    local result = assert(env.con:execute("SELECT ID FROM Member WHERE GuildID = " .. guildId, "{ \"err\":\"Request failed!\" }"))
    local row = result:fetch({})

    local i = 1
    while row do
        memberIds[i] = tonumber(row[1])

        row = result:fetch({})
        i = i + 1
    end

    result:close()

    -- Deleting all the association tables lines.
    deleteMemberCustomCommandsFromList(memberIds)

    -- Then we delete all the warnings.
    wSv.deleteFromMemberList(memberIds)

    -- And we can finally delete all members for the given guild.
    local requestSkeleton = [[
        DELETE FROM Member
        WHERE GuildID = %s
        ;
    ]]

    local request = string.format(requestSkeleton, guildId)

    assert(env.con:execute(request), "{ \"err\":\"Request failed!\" }")
    -- Aaand... that's it. Nothing more to do here
end

---
--- Calls for the environment set in this service to close. Has to be called at the very end of all treatments!!
---
--- @return void
---
function MemberService.closeEnv()
    uSv.closeEnv()
    gSv.closeEnv()
    wSv.closeEnv()
    ccSv.closeEnv()
    env.close()
end

return MemberService